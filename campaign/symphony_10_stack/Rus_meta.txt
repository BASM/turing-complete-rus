kind = sequential
title = "Стек"
size = [-256, -256, 255, 255]
immutable_spec = true
copy_solution_to_level = ["symphony_11_functions"]
no_score = true
dialogue = [
    (info, `Задача этого уровня реализовать общую программную структуру, называемую stack(стек). Вам нужно сделать это на ассемблере. Вы можете выполнять две операции со стеком:

[code]PUSH[/code] - Добавляет число в стек
[code]POP[/code] - Удаляет последнее добавленное значение из стека

Вы можете представить структуру данных stack(стек) как физическую стопку тарелок в оживленном ресторане. Посудомойщик добавляет тарелки на вершину стопки, а повар снимает их.

Прочитайте входные данные на этом уровне, чтобы получить следующую операцию.
Ненулевое значение это push, в этом случае сохраните значение, чтобы его можно было позже извлечь.
Значение 0 это pop, удалите и выведите последнее сохраненное число.
`),
]
post_mortem = [
  (alien, `Поскольку стек настолько полезен для программирования, инструкция "push" и "pop" будет добавлена в следующий уровень Symphony. Обе эти инструкции являются синонимами двух других инструкций и используют регистр "sp" (сокращение от stack pointer) для отслеживания стека.

"push" является синонимом для:
[code]sub sp, sp, 2
store [sp], %value[/code]

"pop" является синонимом для:
[code]load %destination, [sp]
add sp, sp, 2[/code]

Вы можете заметить, что "push" вычитает из "sp", так что стек растет вниз от высоких адресов. Что позволяет использовать нижнюю память по вашему усмотрению.
  `)
]
default_isa_spec = `
[settings]
name = "Symphony"

[fields]

регистр
zr 0000
r1 0001
r2 0010
r3 0011
r4 0100
r5 0101
r6 0110
r7 0111
r8 1000
r9 1001
r10 1010
r11 1011
r12 1100
r13 1101
sp 1110
flags 1111

[instructions]

or %a(регистр), %b(регистр), %c(регистр)
01000001 aaaabbbb 0000cccc 00000000
ИЛИ(OR) %b и %c и сохранить результат в %a.

nand %a(регистр), %b(регистр), %c(регистр)
01000000 aaaabbbb 0000cccc 00000000
ИСКЛ-ИЛИ(NAND) %b и %c и сохранить результат в %a.

nor %a(регистр), %b(регистр), %c(регистр)
01000011 aaaabbbb 0000cccc 00000000
ИЛИ-НЕ(NOR) %b и %c и сохранить результат в %a.

and %a(регистр), %b(регистр), %c(регистр)
01000010 aaaabbbb 0000cccc 00000000
И(AND) %b и %c и сохранить результат в %a.

add %a(регистр), %b(регистр), %c(регистр)
01000100 aaaabbbb 0000cccc 00000000
СЛОЖИТЬ %b + %c и сохранить результат в %a.

sub %a(регистр), %b(регистр), %c(регистр)
01000101 aaaabbbb 0000cccc 00000000
ВЫЧЕСТЬ %b - %c и сохранить результат в %a.

xor %a(регистр), %b(регистр), %c(регистр)
01000110 aaaabbbb 0000cccc 00000000
ИСКЛ-ИЛИ(XOR) %b и %c и сохранить результат в %a.

lsl %a(регистр), %b(регистр), %c(регистр)
01000111 aaaabbbb 0000cccc 00000000
ЛОГИЧЕСКИЙ СДВИГ ВЛЕВО %b на %c и сохранить результат в %a.

lsr %a(регистр), %b(регистр), %c(регистр)
01001000 aaaabbbb 0000cccc 00000000
ЛОГИЧЕСКИЙ СДВИГ ВПРАВО %b на %c и сохранить результат в %a.

cmp %a(регистр), %b(регистр)
01001001 1111aaaa 0000bbbb 00000000
Сравнивает %a и %b и сохраняет результат сравнения в r6.

or %a(регистр), %b(регистр), %c(явное число)
01010001 aaaabbbb cccccccc cccccccc
ИЛИ(OR) %b и %c и сохранить результат в %a.

nand %a(регистр), %b(регистр), %c(явное число)
01010000 aaaabbbb cccccccc cccccccc
И-НЕ(NAND) %b и %c и сохранить результат в %a.

nor %a(регистр), %b(регистр), %c(явное число)
01010011 aaaabbbb cccccccc cccccccc
И-НЕ(NOR) %b и %c и сохранить результат в %a.

and %a(регистр), %b(регистр), %c(явное число)
01010010 aaaabbbb cccccccc cccccccc
И %b и %c и сохранить результат в %a.

add %a(регистр), %b(регистр), %c(явное число)
01010100 aaaabbbb cccccccc cccccccc
СЛОЖЕНИЕ(ADD) %b и %c и сохранить результат в %a.

sub %a(регистр), %b(регистр), %c(явное число)
01010101 aaaabbbb cccccccc cccccccc
ВЫЧЕСТЬ %b - %c и сохранить результат в %a.

xor %a(регистр), %b(регистр), %c(явное число)
01010110 aaaabbbb cccccccc cccccccc
ИСКЛ-ИЛИ(XOR) %b и %c и сохранить результат в %a.

lsl %a(регистр), %b(регистр), %c(явное число)
01010111 aaaabbbb cccccccc cccccccc
ЛОГИЧЕСКИЙ СДВИГ ВЛЕВО %b и %c и сохранить результат в %a.

lsr %a(регистр), %b(регистр), %c(явное число)
01011000 aaaabbbb cccccccc cccccccc
ЛОГИЧЕСКИЙ СДВИГ ВПРАВО %b и %c и сохранить результат в %a.

cmp %a(регистр), %b(явное число)
01011001 1111aaaa bbbbbbbb bbbbbbbb
Сравнивает %a и %b и сохраняет результат сравнения в r6.

jmp %a(регистр)
10001000 00001111 0000aaaa 00000000
Переход к %a.

jmp %a(явное число | метка)
10011000 00001111 aaaaaaaa aaaaaaaa
Переход к %a

je %a(явное число | метка)
10010001 00001111 aaaaaaaa aaaaaaaa
Переход к %a, если значения были равны (чтение результатов из 'flags').

jne %a(явное число | метка)
10011001 00001111 aaaaaaaa aaaaaaaa
Переход к %a, если значения не были равны (чтение результатов из 'flags').

jb %a(явное число | метка)
10010010 00001111 aaaaaaaa aaaaaaaa
Переход к %a, если первое значение было меньше (беззнаковое сравнение) второго (чтение результатов из 'flags').

jae %a(явное число | метка)
10011010 00001111 aaaaaaaa aaaaaaaa
Переход к %a, если первое значение было больше (беззнаковое сравнение) или равно второму (чтение результатов из 'flags').

jbe %a (явное число | метка)
10010011 00001111 aaaaaaaa aaaaaaaa
Переход к %a, если первое значение было меньше (беззнаковое сравнение) или равно второму (чтение результатов из 'flags').

ja %a (явное число | метка)
10011011 00001111 aaaaaaaa aaaaaaaa
Переход к %a, если первое значение было больше (беззнаковое сравнение) второго (чтение результатов из 'flags').

jl %a (явное число | метка)
10010100 00001111 aaaaaaaa aaaaaaaa
Переход к %a, если первое значение было меньше (знаковое сравнение) второго (чтение результатов из 'flags').

jge %a (явное число | метка)
10011100 00001111 aaaaaaaa aaaaaaaa
Переход к %a, если первое значение было больше (знаковое сравнение) или равно второму (чтение результатов из 'flags').

jle %a (явное число | метка)
10010101 00001111 aaaaaaaa aaaaaaaa
Переход к %a, если первое значение было меньше (знаковое сравнение) или равно второму (чтение результатов из 'flags').

jg %a (явное число | метка)
10011101 00001111 aaaaaaaa aaaaaaaa
Переход к %a, если первое значение было больше (знаковое сравнение) второго (чтение результатов из 'flags').

in %a(регистр)
00000001 aaaa0000 00000000 00000000
Загружает входные данные и сохраняет их в %a

out %a(регистр)
00000010 00000000 0000aaaa 00000000
Отправляет %a на выход

keyboard %a(регистр)
00001001 aaaa0000 00000000 00000000
Загружает ввод с клавиатуры и сохраняет его в %a

console %a(регистр)
00000011 00000000 0000aaaa 00000000
Сохраняет значение %a в регистр смещения консоли

console %a(явное число)
00010011 00000000 0000aaaa 00000000
Сохраняет значение %a в регистр смещения консоли

time_0 %a(регистр)
00000100 aaaa0000 00000000 00000000
Загружает первые два байта значения времени и сохраняет их в %a

time_1 %a(регистр)
00000101 aaaa0000 00000000 00000000
Загружает вторые два байта значения времени и сохраняет их в %a

time_2 %a(регистр)
00000110 aaaa0000 00000000 00000000
Загружает третьи два байта значения времени и сохраняет их в %a

time_3 %a(регистр)
00000111 aaaa0000 00000000 00000000
Загружает четвертые два байта значения времени и сохраняет их в %a

counter %a(регистр)
00001000 aaaa0000 00000000 00000000
Загружает значение счетчика и сохраняет его в %a

load %dest(регистр), [%address(регистр)]
11000000 dddd0000 0000aaaa 00000000
Загружает %address из ОЗУ и сохраняет его в %dest

store [%address (регистр)], %value (регистр)
11000001 0000vvvv 0000aaaa 00000000
Сохраняет %value в %address в ОЗУ

load %dest(регистр), [%address(явное число)]
11010000 dddd0000 aaaaaaaa aaaaaaaa
Загружает %address из ОЗУ и сохраняет его в %dest

store [%address(явное число)], %value(регистр)
11010001 0000vvvv aaaaaaaa aaaaaaaa
Сохраняет %value в %address в ОЗУ

pload %dest(регистр), [%address(регистр)]
11000010 dddd0000 0000aaaa 00000000
Загружает %address из SSD и сохраняет его в %dest

pstore [%address(регистр)], %value(регистр)
11000011 0000vvvv 0000aaaa 00000000
Сохраняет %value в %address в SSD

pload %dest(регистр), [%address(явное число)]
11010010 dddd0000 aaaaaaaa aaaaaaaa
Загружает %address из SSD и сохраняет его в %dest

pstore [%address(явное число)], %value(регистр)
11010011 0000vvvv aaaaaaaa aaaaaaaa
Сохраняет %value в %address в SSD

mov %a(регистр), %b(регистр)
01000001 aaaabbbb 00000000 00000000
Перемещает значение в %a из %b

neg %a(регистр), %b(регистр)
01000101 aaaa0000 0000bbbb 00000000
Меняет знак %b и сохраняет результат в %a

not %a(регистр), %b(регистр)
01000011 aaaa0000 0000bbbb 00000000
Выполняет побитовую операцию NOT над %b и сохраняет результат в %a

mov %a(регистр), %b(явное число)
01010001 aaaa0000 bbbbbbbb bbbbbbbb
Перемещает значение в %a из %b

neg %a(регистр), %b(явное число)
01010101 aaaa0000 bbbbbbbb bbbbbbbb
Меняет знак %b и сохраняет результат в %a

not %a(регистр), %b(явное число)
01010011 aaaa0000 bbbbbbbb bbbbbbbb
Выполняет побитовую операцию NOT над %b и сохраняет результат в %a

nop
00000000 00000000 00000000 00000000
Ничего не делает

`
